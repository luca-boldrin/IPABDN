\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Polkadot}
\subsection{What's Polkadot?}

Polkadot is an heterogeneous multi-chain system~\cite{wood2016polkadot}, the aim is to provide a scalable and interoperable framework for multiple chains with shared security.~\cite{burdges2020overview}

At the center of the entire system there is the `relay chain`, responsible for providing shared security to the other chains that are part of the system. Those chains are called `parachains`, they can be heterogeneous and independent between each others; the central point (relay chain) enables a trust-free inter-chain transactability and the pooled security.~\cite{burdges2020overview}

%LB>> "trust-free" may deserve some explanations. how does it add to parachain trust-freeness?

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{polkadot_architecture.png}
  \caption{Polkadot's Architecture}
  \label{fig:polkadot_arch}
\end{figure}

Polkadot provides the bedrock relay-chain upon which a large number of validatable, globally-coherent dynamic data-structures may be hosted side-by-side.~\cite{wood2016polkadot}. While this is normally the case, parachains are not necessarily blockchains: they must just comply with the polkadot protocol.

The Figure \ref{fig:polkadot_arch} shows in the middle the relay chain that connects multiple parachains.

\subsection{Polkadot's protocol}

As already mentioned, the relay chain interacts with many parachains. For the relay chain the internals of the parachians are not relevant as far as they adhere to a specific interface. The relay chain then ensures that the parachain is trustable as a whole, independently from its structure.

The ecosystem expectz multiple actors to make the protocol work, the main being:
\begin{description}[font=$\bullet$ \scshape\bfseries]
  \item[Validator] Performs the bulk of the security work
  \item[Nonimator] Stakeholder who backs and selects validator candidates
  \item[Collator] Collects and submits parachain data to the relay chain
\end{description}

The protocol is composed by multiple phases and it defines the communication between parties. The main processes are:~\cite{burdges2020overview}

%LB>> the list below seems more a specification of "roles" of the differnet entities. I have the feeling it needs to be reworked to present a clear series of sequential steps in a process.

\begin{enumerate}
  \item The parachain's collators:
        \begin{itemize}
                \item Runs full relay chain node to keep up the latest state
                \item Builds new blocks on top of the latest state and submit blocks to the parachain's validator
        \end{itemize}
  \item The relay chain's validators:
    \begin{itemize}
      \item The ones associated to parachians produce the new relay chain blocks candidate
      \item Follows a sub-protocol to ensure data sharding. Data are mainly parachain blocks and sharding is the process of making the validators collectively and robustly responsible for the availability of these blocks using erasure coding

%LB>> either explain "erasure coding" or put a reference.

      \item Submit votes to resolve forks and have a single head

%LB>> sentence above unclear.

      
      \item Manage messages between parachians
    \end{itemize}
\end{enumerate}

\subsubsection{State Transition Function}

The protocol demonstrates how the main goal is to verify what's happened on parachains, described by the parachain logic. 

%LB>> "verify" or "notarize"? Moreover, it is not clear to me how the protocol described above demonstrates that...


One of the few required thing to a parachain is indeed that they provides a State Transition Function (STF), which implements the parachain logic and produces the transition between two states. Like any transaction-based transition system, Polkadot state changes via  executing an ordered set of instructions, known as extrinsics.~\cite{burdges2020overview}

%LB>> I took the freedom to change "defines" into "implements". is it correct?.


The STF is also present in every validator node because it implements the relay chain logic. 

%LB>> ====start added text===========

As it will be made clear in the following, STFs need to run on heterogeneous nodes while providing the same results. It is straightforward then to implement them as platform agnosic bytecode components.

%LB>> ====end added text===========


Generally STFs in polkadot are implemented as Wasm blob. It would be possible to use different PABs to implement the STF but that wouls add complexity with respect to the Wams-based soulution that will be described in the following.

Every parachain or relay chain node can be divided into two parts: the STF (or Runtime) and the Client. The latter one implements everything else required to make the protocol work, from storage management to transaction gossiping.

Generally, the runtime is compiled into Wasm and stored as part of the state. This allows making fork-less upgrades because the code transition happens under consensus in the STF.

%LB>> the sentence above needs some elaborations


\subsection{Wasm in Polkadot}

Substrate is a framework to build blockchains. It is separate from Polkadot, and it supports building "Solo Chains", i.e.  blockchains able to run on their own without any relation to the polkadot protocols.

Substrate is the main (and unique for now) framework used to build blockchains in the Polkadot ecosystem. Even the relay chain is built with substrate. 
Substrate abstracts all the complexity of writing client and runtime code. It  already provides almost everything necessary at client level and gives the freedom of developing everything in the runtime, i.e. the specific state transition function of the custom blockchain.

Substrate compiles the runtime to Wasm and the client has an embedder, wasmtime, able to run the STF. As long as the chain is a Solo Chain substrate manages everything: it compiles the runtime in wasm and implements all the custom logic to make the client and the runtime communicate through the embedder wasmtime.

Some problems occur when you want your blockchain to be part of the polkadot ecosystem, where there is pooled security. For this reason the logic must be executed not anly by the nodes that compose the parachain but also by the validators of the relay chain. This is made possible following a protocol made by multiple phases that are built on top of two building blocks: the Parachain Validation Function (PVF) and the Proof of Validity (PoV).~\cite{parachain-protocol}

\subsubsection{PVF}

Using Substrate you end up with a Substrate-Runtime,  a wasm blob that implements the State Transition Function of your blockchain. To be included as a parachain in polkadot you need to provide to the relay chain something that differs a bit from the Substrate-Runtime.

The protocol requires a Parachain Validation Function that is composed of the Substrate-Runtime and another function called 'validate\_block'. The reason why this function is required is related to a constraint of the relay chain: polkadot does not know anything about the previous state of the parachain.

Everything needed by the Runtime is not present in the validators node but is provided in the block proposed by the collators, that's called "PoV". The structure of the PoV will be explained later, for now it suffice to know that every information needed in the execution of the PVF is indeed in the PoV.

The 'validate\_block' function is the glue between the parachain-runtime and the PoV: it accepts the PoV and reconstructs the previous state, it applies all the extrinsics using the parachain-runtime and then checks that the new state is consistent with the one proposed by the collators.

Both relay chain and parachain implement the same HostFunctions for the runtime. This means that the STF of the parachain would access the storage through the same functions in the relay chain and in the parachain but what is known by the nodes is different.

As was just said the relay chain does not know the previous state of the parachain but the information resides in the PoV. The function 'validate\_block' overrides the host functions to let the STF access the reconstructed internal state, present in the PoV, instead of going into the relay chain client.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\linewidth]{validate_block_expl.png}
  \caption{PVF and Collation}
  \label{fig:pvf_pov}
\end{figure}

"Collation" is the term used to represent the outcome produced by the collators that will be used by validators, so it is a synonymous for PoV.

%maybe this is redundant

From the \ref{fig:pvf_pov} you can see how the parachain-runtime interacts in the same way with the embedder. It behaves differntly  in the Collator and in the Validator: in the first case the embedder is the client itself that knows the previous state, while  in the Validator the embedder in the client is tweaked a bit so that the previous state is taken from the PoV and not from the Validator.

This encapsulation with a substitution of the host functions makes  the validator able to execute different STFs without knowing anything about the parachain that is validating.

\subsubsection{PoV}

The Proof of Validity is made by all the things needed by Runtime Validation, it is mainly composed by:~\cite{cumulus-docs}

\begin{itemize}
  \item Header of the new block
  \item Transactions included in the block
  \item Witness Data
  \item Outgoing messages
\end{itemize}

The witness data is what makes possible the state transition validation without knowing the entire state of the parachain by the relay-chain.

The state in polkadot is managed as a Merkle-Patricia Base 16 Tree where the hash of the root defines the state proof. The state proof of the previous block is stored in the relay chain and the witness data are:

% TODO: explain Merkle-Patricia Base 16 Trie ? -- and add reference
% maybe poit to the repo: https://github.com/paritytech/trie

\begin{itemize}
  \item Data used in the state transition by the collator
  \item Alongside their inclusion proof in the previous state
\end{itemize}

%LB>> is the following better suited for a separate subparagraph? does it need to be extended a bit?

The Outgoing messages are everything that needs to be delivered to other parachains. The underneath protocol is XCMP following the XCM format which enables the parachain communication between parachains or with the relay chain.

\subsubsection{SmartContracts}

SmartContracts are arbitrary programs that can be uploaded on-chain and executed in the state transition function. The STF is itself an arbitrary program that can be updated, but the convenience of SmartContracts is the easiness of creating and uploading custom logic on-chain by final users. Different blockchains implement SmartContracts in different forms.  Polkadot implements SmartContracts with a recursive embedder.

The Client is the embedder of the STF and the STF becomes in its turn the embedder of the SmartContracs.  This is made possible by Wasmi because it can be executed even in wasm itself. To secure the execution of arbitrary, possibly malicious code,  there are different solutions:

\begin{itemize}
  \item Gas / Fuel measuring
  \item Storage usage deposit
\end{itemize}

The first solution limits the number of operations that can be executed in the STF, while   the second  limits the amount of used storage.

\subsection{The crucial Role of WASM in Polkadot}

As it appears from the previous sections, the distributed algorithms at the different levels would be useless if nodes couldn't execute them a secure and deterministic manner.

The amount of tools and projects that are using Wasm makes it very suitable for polkadot, an environment with very constrained resources: there is limited space on every block, every state transition must be computed in a limited amount of time and multiple nodes must reach the same results. Wasm has already multiple tools like space and efficiency optimizer that makes it the optimal choice for polkadot.

An important tool is \href{https://github.com/WebAssembly/binaryen}{Binaryen} with the wasm-opt optimization phases, largely used in polkadot, that loads WebAssembly and runs Binaryen IR passes on it to make it more space and complexity efficient.

%LB>> explain Binaryen a bit, and add reference.

% \subsubsection{SPREE}

\end{document}
